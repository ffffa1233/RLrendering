/* 
* Copyright (C) 2008, Brian Taner

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
* 
*  $Revision: 277 $
*  $Date: 2008-10-01 14:15:48 -0600 (Wed, 01 Oct 2008) $
*  $Author: brian@tannerpages.com $
*  $HeadURL: https://rl-glue-ext.googlecode.com/svn/trunk/projects/codecs/C/src/RL_client_environment.c $
* 
*/

/**
This is a copy of RL_client_environment with a couple 
of specific calls filled in.  To customize the codec, just 
look for places where default calls are happening, like:
env_init, env_start, env_step, etc, etc.. and then write a bit of code to 
emulate the same behavior using whatever project you are hooking into.


All of the inserted code is commented.
All of the previous code in here has been commented out like:*/

/* CUT-FOR-CUSTOMIZATION: env_init();*/



#include <assert.h> /* assert  */
#include <unistd.h> /* sleep   */
#include <string.h> /* strlen */ /* I'm sorry about using strlen. */
#include <stdio.h>  /* fprintf */
#include <stdlib.h> /* calloc, getenv, exit */
#include <math.h>   /* fabs */

#include <ctype.h> /* isdigit */
#include <netdb.h> /* gethostbyname */
#include <arpa/inet.h> /* inet_ntoa */

#include <rlglue/Environment_common.h>
#include <rlglue/network/RL_network.h>

/* Our project specific include */
#include "Test.h"
#include "../Tests/FooTest.h"

/* Include the utility methods*/
#include <rlglue/utils/C/RLStruct_util.h>

static const char* kUnknownMessage = "Unknown Message: %s\n";

static rlBuffer theBuffer = {0};
static action_t this_action = {0};
static char* theInMessage = 0;
static unsigned int theInMessageCapacity = 0;

static observation_t this_observation;
static reward_observation_terminal_t this_reward_observation;

FooTest foo;
b2Body* bodies;

static void onEnvInit(int theConnection) {printf("onEnvInit\n");
  unsigned int theTaskSpecLength = 0;
  unsigned int offset = 0;
  
  char* theTaskSpec = "[VERSION RL-GLue-3.0] [PROBLEMTYPE episodic]" "[OBSERVATIONS DOUBLE (-15.0 ~ 40.0) ]" "[ACTIONS INT (-5 ~ 5) ]" "REWARDS DOUBLE]" "EXTRA environment(C/C++) by PSC, CBH]";

  if (theTaskSpec != NULL) {
    theTaskSpecLength = strlen(theTaskSpec);
  }

  /* Prepare the buffer for sending data back to the server */
  rlBufferClear(&theBuffer);
  offset = rlBufferWrite(&theBuffer, offset, &theTaskSpecLength, 1, sizeof(int));
  if (theTaskSpecLength > 0) {
    offset = rlBufferWrite(&theBuffer, offset, theTaskSpec, theTaskSpecLength, sizeof(char));
  }

  allocateRLStruct(&this_observation,0,1,0);
  
  this_reward_observation.observation = &this_observation;
  this_reward_observation.reward = 0;
  this_reward_observation.terminal = 0;
}

static void onEnvStart(int theConnection) {printf("onEnvStart\n");
  	unsigned int offset = 0;

	this_observation.doubleArray[0] = foo.get_position();
	__RL_CHECK_STRUCT(&this_observation)
	
	rlBufferClear(&theBuffer);
	offset = rlCopyADTToBuffer(&this_observation, &theBuffer, offset);
}

static void onEnvStep(int theConnection) {printf("onEnvStep\n");
	double the_reward = 0.0;
	unsigned int offset = 0;
	int force = 0;
	double posx = 0;

	offset = rlCopyBufferToADT(&theBuffer, offset, &this_action);
	__RL_CHECK_STRUCT(&this_action);

	force = this_action.intArray[0];

	foo.apply_force(force);
	posx = foo.get_position();
printf("%lf, %d\n",posx,force);
	the_reward = 100 - fabs(posx - 15);
	this_reward_observation.observation->doubleArray[0] = posx;
	this_reward_observation.reward = the_reward;
	this_reward_observation.terminal = check_terminal(posx);

	__RL_CHECK_STRUCT(this_reward_observation.observation);
	rlBufferClear(&theBuffer);
	offset = 0;
	offset = rlBufferWrite(&theBuffer, offset, &this_reward_observation.reward, 1, sizeof(double));
	offset = rlBufferWrite(&theBuffer, offset, &this_reward_observation.terminal, 1, sizeof(int));
	offset = rlCopyADTToBuffer(this_reward_observation.observation, &theBuffer, offset);
}

static void onEnvCleanup(int theConnection) {printf("onEnvCleanup\n");
	rlBufferClear(&theBuffer);
	clearRLStruct(&this_action);
	clearRLStruct(&this_observation);

	free(theInMessage);
	theInMessage = 0;
	theInMessageCapacity = 0;
}


static void onEnvMessage(int theConnection) {
  unsigned int inMessageLength = 0;
  unsigned int outMessageLength = 0;
  char* inMessage = 0;
  /*We set this to a string constant instead of null*/
  char* outMessage = "sample custom codec integration has no messages!";
  unsigned int offset = 0;

  offset = 0;
  offset = rlBufferRead(&theBuffer, offset, &inMessageLength, 1, sizeof(int));
  if (inMessageLength >= theInMessageCapacity) {
    inMessage = (char*)calloc(inMessageLength+1, sizeof(char));
    free(theInMessage);

    theInMessage = inMessage;
    theInMessageCapacity = inMessageLength;
  }

  if (inMessageLength > 0) {
    offset = rlBufferRead(&theBuffer, offset, theInMessage, inMessageLength, sizeof(char));
  }
/*Make sure to null terminate the string */
   theInMessage[inMessageLength]='\0';

	/* CUT-FOR-CUSTOMIZATION: outMessage = env_message(theInMessage);*/

  if (outMessage != NULL) {
   outMessageLength = strlen(outMessage);
  }

  
  /* we want to start sending, so we're going to reset the offset to 0 so we write the the beginning of the buffer */
  rlBufferClear(&theBuffer);
  offset = 0;
  offset = rlBufferWrite(&theBuffer, offset, &outMessageLength, 1, sizeof(int));
  if (outMessageLength > 0) {
    offset = rlBufferWrite(&theBuffer, offset, outMessage, outMessageLength, sizeof(char));
  }
}

void runEnvironmentEventLoop(int theConnection) {
  int envState = 0;

  do { 
    rlBufferClear(&theBuffer);
    rlRecvBufferData(theConnection, &theBuffer, &envState);
    switch(envState) {
    case kEnvInit:
      onEnvInit(theConnection);
      break;

    case kEnvStart:
      onEnvStart(theConnection);
      break;

    case kEnvStep:
      onEnvStep(theConnection);
      break;

    case kEnvCleanup:
      onEnvCleanup(theConnection);
      break;

    case kEnvMessage:
      onEnvMessage(theConnection);
      break;

    case kRLTerm:
      break;

    default:
      fprintf(stderr, kUnknownMessage, envState);
      exit(0);
      break;
    };

    rlSendBufferData(theConnection, &theBuffer, envState);
  } while (envState != kRLTerm);
}

/*This used to be the main method, I've renamed it and cut a bunch of stuff out*/
int setup_rlglue_network() {
	int theConnection = 0;

	char* host = kLocalHost;
	short port = kDefaultPort;

	printf("RL-Glue Testbed environment  custom codec integration.\n");

	/* Allocate what should be plenty of space for the buffer - it will dynamically resize if it is too small */
	rlBufferCreate(&theBuffer, 4096);

	theConnection = rlWaitForConnection(host, port, kRetryTimeout);

	printf("\tRL-Glue Testbed environment custom codec :: Connected\n");
	rlBufferClear(&theBuffer);
	rlSendBufferData(theConnection, &theBuffer, kEnvironmentConnection);

	return theConnection;
}

void teardown_rlglue_network(int theConnection){
	rlClose(theConnection);
	rlBufferDestroy(&theBuffer);
}

int check_terminal(double current_state){
	if(current_state<=15.1 && current_state>=14.9){
		return 1;
	}
	if(current_state> 40 || current_state< -10){
		return 1;
	}
	return 0;
}
